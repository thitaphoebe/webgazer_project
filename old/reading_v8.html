<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ReadAid</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      width: 100vw; height: 100vh;
      position: relative;
      overflow: hidden;
    }

    #calibration-instruction {
      position: absolute;
      top: 10px; width: 100%;
      text-align: center;
      font-size: 1.5em;
      color: darkred;
      z-index: 10000;
    }

    .calibration-dot {
      width: 30px; height: 30px;
      border-radius: 50%;
      background: red;
      position: absolute;
      transform: translate(-50%, -50%);
      cursor: pointer;
      opacity: 1;
      transition: opacity 0.3s;
      z-index: 10001;
    }

    /* only vertical centering now */
    #container {
      display: none;
      position: absolute;
      top: 50%;
      left: 0; right: 0;
      transform: translateY(-50%);
      padding: 20px;
      text-align: center;
      z-index: 10000;
    }

    #readingText span {
      display: inline-block;
      margin: 6px;
      padding: 8px;
      font-size: 5em;
      border-radius: 4px;
    }
    .gaze-on      { background: lightgreen; }
    .highlighted  { background: yellow; }

    #exportButton {
      display: none;
      position: absolute;
      top: 20px; right: 20px;
      padding: 8px 12px;
      font-size: 1em;
      z-index: 10000;
    }

    /* optional: style the video preview */
    #webgazerVideoFeed {
      position: absolute;
      top: 10px; left: 10px;
      width: 160px; height: 120px;
      border: 2px solid #666;
      z-index: 9998;
    }
  </style>
</head>

<body>
  <div id="calibration-instruction">
    คลิกที่จุดเพื่อสอบเทียบ (รอบ 1/3, จุด 1/16)
  </div>
  <button id="exportButton">Export Gaze Data</button>
  <div id="container">
    <div id="readingText">
      <span>ช้าง</span>
      <span>เดิน</span>
      <span>ผ่าน</span>
      <span>ทุ่งหญ้า</span>
      <span>สูง</span>
      <span>อย่าง</span>
      <span>ช้าๆ</span>
    </div>
  </div>
  <audio id="pingSound"
         src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg"
         preload="auto"></audio>

  <!-- load WebGazer -->
  <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
  <script>
  // 1) START WebGazer
  webgazer
    .showVideoPreview(true)
    .showPredictionPoints(true)
    .begin();

  // 2) Calibration setup (4×4 grid from 5% to 95%)
  const margin = 0.05, grid = 4;
  const calibrationPoints = [];
  for (let y=0; y<grid; y++){
    for (let x=0; x<grid; x++){
      calibrationPoints.push([
        margin + x*(1-2*margin)/(grid-1),
        margin + y*(1-2*margin)/(grid-1)
      ]);
    }
  }
  const totalRounds = 3;
  let round = 0, idx = 0;
  const dot = document.createElement('div');
  dot.className = 'calibration-dot';
  document.body.appendChild(dot);

  function updateInstruction(){
    document.getElementById('calibration-instruction').innerText =
      `คลิกที่จุดเพื่อสอบเทียบ (รอบ ${round+1}/${totalRounds}, จุด ${idx+1}/${calibrationPoints.length})`;
  }

  function showDot(){
    const [xr, yr] = calibrationPoints[idx];
    dot.style.left = `${xr * innerWidth}px`;
    dot.style.top  = `${yr * innerHeight}px`;
    dot.style.opacity = '1';
    updateInstruction();
  }

  dot.addEventListener('click', e => {
    webgazer.recordScreenPosition(e.clientX, e.clientY, e);
    dot.style.opacity = '0.3';
    idx++;
    if (idx >= calibrationPoints.length) { idx=0; round++; }
    if (round >= totalRounds) {
      dot.remove();
      document.getElementById('calibration-instruction').remove();
      setTimeout(()=> {
        webgazer.getCurrentPrediction().then(pred => {
          let msg = "Accuracy could not be determined.";
          if (pred && pred.x!=null) {
            const dx = pred.x - innerWidth/2;
            const dy = pred.y - innerHeight/2;
            const d  = Math.hypot(dx,dy);
            const max = Math.hypot(innerWidth,innerHeight)/2;
            const pct = Math.max(0,100 - d/max*100).toFixed(1);
            msg = `Calibration complete!\nEstimated accuracy: ${pct}%`;
          }
          alert(msg);
          document.getElementById('container').style.display = 'block';
          document.getElementById('exportButton').style.display = 'block';
        });
      }, 500);
    } else {
      setTimeout(showDot, 300);
    }
  });

  // 3) kick off first dot
  showDot();

  // 4) Gaze–interaction logic & enhanced logging
  const words = document.querySelectorAll('#readingText span');
  const ping  = document.getElementById('pingSound');
  let lastIdx = null, focusStart = null;
  let pinged = new Set(), recent = [], hover = null, lastT = 0;
  let thaiVoice = null;
  window.speechSynthesis.onvoiceschanged = () => {
    thaiVoice = speechSynthesis.getVoices().find(v=>v.lang==='th-TH');
  };
  function speak(w){
    const u = new SpeechSynthesisUtterance(w);
    u.lang = 'th-TH';
    if (thaiVoice) u.voice = thaiVoice;
    speechSynthesis.speak(u);
  }
  function smooth(x,y){
    recent.push({x,y});
    if (recent.length>5) recent.shift();
    return {
      x: recent.reduce((a,b)=>a+b.x,0)/recent.length,
      y: recent.reduce((a,b)=>a+b.y,0)/recent.length
    };
  }
  function getWordAt(x,y){
    for (let i=0;i<words.length;i++){
      const r = words[i].getBoundingClientRect();
      if (x>=r.left && x<=r.right && y>=r.top && y<=r.bottom) return i;
    }
    return null;
  }
  // now we include wordIndex & word text
  const rawLog = [];
  webgazer.setGazeListener((data,ts)=>{
    if (!data) return;
    if (ts - lastT < 50) return;
    lastT = ts;

    const { x, y } = smooth(data.x, data.y);
    const wi = getWordAt(x, y);

    rawLog.push({
      x: data.x.toFixed(1),
      y: data.y.toFixed(1),
      t: Math.round(ts),
      wordIndex: wi,
      word: wi != null ? words[wi].innerText : ''
    });

    // highlight logic (unchanged)…
    if (wi !== hover) {
      words.forEach(w=>w.classList.remove('gaze-on','highlighted'));
      if (wi!=null) words[wi].classList.add('gaze-on');
      hover = wi;
    }
    if (wi!=null) {
      if (!pinged.has(wi)) {
        ping.currentTime = 0;
        ping.play();
        pinged.add(wi);
      }
      if (wi === lastIdx) {
        if (!focusStart) focusStart = performance.now();
        if (performance.now() - focusStart > 2000) {
          words[wi].classList.replace('gaze-on','highlighted');
          speak(words[wi].innerText);
          focusStart = null;
          pinged.delete(wi);
        }
      } else {
        lastIdx = wi;
        focusStart = performance.now();
      }
    } else {
      lastIdx = null;
      focusStart = null;
      pinged.clear();
    }
  }).begin();

  // 5) Export CSV with the two new columns
  document.getElementById('exportButton')
    .addEventListener('click', ()=>{
      const header = ['x','y','t','wordIndex','word'];
      const rows = [ header.join(',') ];
      rawLog.forEach(p=>{
        rows.push(
          `${p.x},${p.y},${p.t},${p.wordIndex},${p.word}`
        );
      });
      const blob = new Blob([rows.join("\n")], { type:"text/csv" });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'gaze_data.csv';
      a.click();
      URL.revokeObjectURL(a.href);
    });
  </script>
</body>
</html>
