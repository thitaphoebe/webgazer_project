<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ReadAid</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      width: 100vw; height: 100vh;
      position: relative;
      overflow: hidden;
    }
    #calibration-instruction {
      position: absolute;
      top: 10px; width: 100%;
      text-align: center;
      font-size: 1.5em;
      color: darkred;
      z-index: 10000;
    }
    .calibration-dot {
      width: 30px; height: 30px;
      border-radius: 50%;
      background: red;
      position: absolute;
      transform: translate(-50%, -50%);
      cursor: pointer;
      opacity: 1;
      transition: opacity 0.3s;
      z-index: 10001;
    }
    #container {
      display: none;
      position: absolute;
      top: 50%;
      left: 0; right: 0;
      transform: translateY(-50%);
      padding: 20px;
      text-align: center;
      z-index: 10000;
    }
    #readingText span {
      display: inline-block;
      margin: 6px;
      padding: 8px;
      font-size: 5em;
      border-radius: 4px;
    }
    .gaze-on      { background: lightgreen; }
    .highlighted  { background: yellow; }
    #exportButton {
      display: none;
      position: absolute;
      top: 20px; right: 20px;
      padding: 8px 12px;
      font-size: 1em;
      z-index: 10000;
    }
    #webgazerVideoFeed {
      position: absolute;
      top: 10px; left: 10px;
      width: 160px; height: 120px;
      border: 2px solid #666;
      z-index: 9998;
    }
    #nextSentenceBtn {
      display: none;
      margin: 40px auto 0 auto;
      font-size: 2em;
      padding: 8px 30px;
      border-radius: 10px;
      background: #0080ff;
      color: white;
      border: none;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <div id="calibration-instruction">
    คลิกที่จุดเพื่อสอบเทียบ (รอบ 1/3, จุด 1/16)
  </div>
  <button id="exportButton">Export Gaze Data</button>
  <div id="container">
    <div id="readingText"></div>
    <button id="nextSentenceBtn">ประโยคถัดไป</button>
  </div>
  <audio id="pingSound"
         src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg"
         preload="auto"></audio>

  <!-- PapaParse for CSV loading -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- load WebGazer -->
  <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
  <script>
  // 1) START WebGazer
  webgazer
    .showVideoPreview(true)
    .showPredictionPoints(true)
    .begin();

  // 2) Calibration setup (same as before)
  const margin = 0.05, grid = 4;
  const calibrationPoints = [];
  for (let y=0; y<grid; y++){
    for (let x=0; x<grid; x++){
      calibrationPoints.push([
        margin + x*(1-2*margin)/(grid-1),
        margin + y*(1-2*margin)/(grid-1)
      ]);
    }
  }
  const totalRounds = 3;
  let round = 0, idx = 0;
  const dot = document.createElement('div');
  dot.className = 'calibration-dot';
  document.body.appendChild(dot);

  function updateInstruction(){
    document.getElementById('calibration-instruction').innerText =
      `คลิกที่จุดเพื่อสอบเทียบ (รอบ ${round+1}/${totalRounds}, จุด ${idx+1}/${calibrationPoints.length})`;
  }

  function showDot(){
    const [xr, yr] = calibrationPoints[idx];
    dot.style.left = `${xr * innerWidth}px`;
    dot.style.top  = `${yr * innerHeight}px`;
    dot.style.opacity = '1';
    updateInstruction();
  }

  dot.addEventListener('click', e => {
    webgazer.recordScreenPosition(e.clientX, e.clientY, e);
    dot.style.opacity = '0.3';
    idx++;
    if (idx >= calibrationPoints.length) { idx=0; round++; }
    if (round >= totalRounds) {
      dot.remove();
      document.getElementById('calibration-instruction').remove();
      setTimeout(()=> {
        webgazer.getCurrentPrediction().then(pred => {
          let msg = "Accuracy could not be determined.";
          if (pred && pred.x!=null) {
            const dx = pred.x - innerWidth/2;
            const dy = pred.y - innerHeight/2;
            const d  = Math.hypot(dx,dy);
            const max = Math.hypot(innerWidth,innerHeight)/2;
            const pct = Math.max(0,100 - d/max*100).toFixed(1);
            msg = `Calibration complete!\nEstimated accuracy: ${pct}%`;
          }
          alert(msg);
          // --- Wait to show main experiment until CSV is loaded ---
          if (sentencesLoaded) {
            showSentence(currentSentenceIdx);
            document.getElementById('container').style.display = 'block';
            document.getElementById('exportButton').style.display = 'block';
          } else {
            containerShouldShow = true; // Wait for CSV loading!
          }
        });
      }, 500);
    } else {
      setTimeout(showDot, 300);
    }
  });

  // 3) kick off first dot
  showDot();

  // === NEW SECTION: Load Sentences from CSV ===
  let sentences = [];
  let sentencesLoaded = false;
  let containerShouldShow = false;

  Papa.parse('sentences.csv', {
    download: true,
    header: true,
    complete: function(results) {
      // Only keep non-empty sentences
      sentences = results.data.map(row => row.sentence)
        .filter(s => s && s.trim().length > 0);

      // Shuffle order
      for (let i = sentences.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [sentences[i], sentences[j]] = [sentences[j], sentences[i]];
      }
      sentencesLoaded = true;
      if (containerShouldShow) {
        showSentence(currentSentenceIdx);
        document.getElementById('container').style.display = 'block';
        document.getElementById('exportButton').style.display = 'block';
      }
    }
  });

  // --- Sentence display logic ---
  let currentSentenceIdx = 0;
  let words = [];
  function showSentence(idx) {
    const readingText = document.getElementById('readingText');
    readingText.innerHTML = '';
    if (idx < sentences.length) {
      // Split the sentence into words and create <span> for each
      words = sentences[idx].trim().split(/\s+/).map(word => {
        const span = document.createElement('span');
        span.textContent = word;
        readingText.appendChild(span);
        return span;
      });
      document.getElementById('nextSentenceBtn').style.display = (idx < sentences.length-1) ? 'inline-block' : 'none';
    } else {
      readingText.innerHTML = 'Experiment complete. Thank you!';
      document.getElementById('nextSentenceBtn').style.display = 'none';
    }
    resetGazeLogic();
  }

  // Next sentence button
  document.getElementById('nextSentenceBtn').addEventListener('click', () => {
    currentSentenceIdx++;
    showSentence(currentSentenceIdx);
  });

  // 4) Gaze–interaction logic & enhanced logging (modified for dynamic words)
  const ping  = document.getElementById('pingSound');
  let lastIdx = null, focusStart = null;
  let pinged = new Set(), recent = [], hover = null, lastT = 0;
  let thaiVoice = null;
  window.speechSynthesis.onvoiceschanged = () => {
    thaiVoice = speechSynthesis.getVoices().find(v=>v.lang==='th-TH');
  };

  function speak(w){
    const u = new SpeechSynthesisUtterance(w);
    u.lang = 'th-TH';
    if (thaiVoice) u.voice = thaiVoice;
    speechSynthesis.speak(u);
  }
  function smooth(x,y){
    recent.push({x,y});
    if (recent.length>5) recent.shift();
    return {
      x: recent.reduce((a,b)=>a+b.x,0)/recent.length,
      y: recent.reduce((a,b)=>a+b.y,0)/recent.length
    };
  }
  function getWordAt(x,y){
    if (!words.length) return null;
    for (let i=0;i<words.length;i++){
      const r = words[i].getBoundingClientRect();
      if (x>=r.left && x<=r.right && y>=r.top && y<=r.bottom) return i;
    }
    return null;
  }
  // now we include wordIndex & word text
  const rawLog = [];
  function resetGazeLogic() {
    lastIdx = null;
    focusStart = null;
    pinged = new Set();
    recent = [];
    hover = null;
    // Optionally, you may want to clear highlights
    words.forEach(w=>w.classList.remove('gaze-on','highlighted'));
  }
  webgazer.setGazeListener((data,ts)=>{
    if (!data) return;
    if (ts - lastT < 50) return;
    lastT = ts;
    const { x, y } = smooth(data.x, data.y);
    const wi = getWordAt(x, y);

    rawLog.push({
      x: data.x ? data.x.toFixed(1) : '',
      y: data.y ? data.y.toFixed(1) : '',
      t: Math.round(ts),
      wordIndex: wi,
      word: (wi != null && words[wi]) ? words[wi].innerText : ''
    });

    // highlight logic (unchanged)…
    if (wi !== hover) {
      words.forEach(w=>w.classList.remove('gaze-on','highlighted'));
      if (wi!=null) words[wi].classList.add('gaze-on');
      hover = wi;
    }
    if (wi!=null) {
      if (!pinged.has(wi)) {
        ping.currentTime = 0;
        ping.play();
        pinged.add(wi);
      }
      if (wi === lastIdx) {
        if (!focusStart) focusStart = performance.now();
        if (performance.now() - focusStart > 2000) {
          words[wi].classList.replace('gaze-on','highlighted');
          speak(words[wi].innerText);
          focusStart = null;
          pinged.delete(wi);
        }
      } else {
        lastIdx = wi;
        focusStart = performance.now();
      }
    } else {
      lastIdx = null;
      focusStart = null;
      pinged.clear();
    }
  }).begin();

  // 5) Export CSV with the two new columns
  document.getElementById('exportButton')
    .addEventListener('click', ()=>{
      const header = ['x','y','t','wordIndex','word'];
      const rows = [ header.join(',') ];
      rawLog.forEach(p=>{
        rows.push(
          `${p.x},${p.y},${p.t},${p.wordIndex},${p.word}`
        );
      });
      const blob = new Blob([rows.join("\n")], { type:"text/csv" });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'gaze_data.csv';
      a.click();
      URL.revokeObjectURL(a.href);
    });
  </script>
</body>
</html>
